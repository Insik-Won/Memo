■ 4. 클래스와 상속

◎ 클래스
	- 코틀린에서 클래스는 class 키워드를 사용해서 만든다.
	- 코틀린에서 클래스의 본문은 생략해도 된다.
	- 코틀린의 기본 접근지정자는 public이다.
	
◎ 생성자
	- 코틀린에서 클래스의 생성자는 클래스의 헤더에 정의한다. 이 생성자를 주 생성자라고 부른다.
	- 헤더의 constructor 키워드는 만약 접근지정자나 어노테이션을 붙이지 않는다면 생략해도 된다.
	- 주 생성자의 매개변수에 기본값을 넣어줄 수 있다.
	- init 블럭은 여러개 만들 수 있으며 프로퍼티 초기화를 포함해 정의된 순서대로 호출된다.
	- constructor 블럭으로 생성된 생성자는 보조 생성자라고 불린다. 보조 생성자는 this를 통해 주 생성자를 호출해야 한다.
	
	- <code>
		class Person constructor(val name: String, var isEmployed: Boolean = false) {
			init {
				println("my name is $name!")
			}

			constructor(name: String, parent: Person) : this(name) {
				println("my parent is ${parent.name}.")
			}
		}
	- </code>
	
◎ 프로퍼티
	- 프로퍼티는 필드처럼 행동하지만 실제로는 getter와 setter를 통해 접근되는 멤버를 말한다.
	- 코틀린에서 프로퍼티 선언 구문은 다음과 같다.
		- <code>
		 var/val <propertyName>[: <PropertyType>] [= <property_initializer>]
			[<getter>]
			[<setter>]
		- </code>
		- getter는 get이라는 이름의 인자가 없는 함수로 선언한다.
		- setter는 set이라는 value 인자 하나를 가지는 함수로 선언한다.
		- getter와 setter에서 실제 값은 field 키워드를 통해 참조한다. 만약 초기화와 field 키워드를 쓰지 않았다면 실제 값은 없게 된다.
		- getter와 setter에 당연히 접근지정자와 어노테이션을 지정할 수 있다.
		- 직접 실제 값을 가지는 private 프로퍼티와 그 프로퍼티에 접근하는 프로퍼티를 만들 수도 있다. 이경우 private 프로퍼티는 필드로 변환된다.		
		- 프로퍼티도 inline이 가능하다.
		
◎ 클래스의 멤버 참조
	- 클래스명::멤버명을 통해 멤버를 참조할 수가 있다.
	- 또한 ::탑레벨멤버명을 통해 탑레벨에 있는 멤버를 참조할 수가 있다.
	- 만약 프로퍼티를 참조할 시 그 타입은 KProperty<T> 혹은 KMutableProperty<T>가 된다.
		
◎ 상속
	- 코틀린에서 기본적으로 클래스와 메소드, 프로퍼티는 final, 상속/오버라이딩이 금지되어 있다. 상수적이다.
	- 만약 상속/오버라이딩을 허용할려면 open 키워드를 클래스/메소드/프로퍼티 선언 앞에 붙여야 한다.
	- 재상속/재오버라이딩을 금지할려면 final 키워드를 선언 앞에 붙여야한다.
	- 프로퍼티 오버라이딩은 주 생성자에서 해도 되며 val 프로퍼티를 var 프로퍼티로 오버라이딩해도 된다. 그 역은 안된다.
	- 부모 클래스는 super 키워드를 통해 참조 가능하며 상위 클래스는 super<상위클래스이름>을 통해 참조 가능하다.
	
	- <code>
		open class Shape {
			open fun draw() { /*...*/ }
			fun fill() { /*...*/ }
		}

		class Circle() : Shape() {
			override fun draw() { /*...*/ }
		}
	- </code>
	
◎ 인터페이스
	- 코틀린에서 인터페이스는 interface 키워드를 통해 선언한다.
	- 메소드/프로퍼티에 기본 구현을 붙일 수 있다.
	- 인터페이스의 프로퍼티는 실제 값을 가질 수 없다.
	- 물론 인터페이스도 인터페이스를 상속할 수 있다.
	
◎ 추상 클래스
	- 코틀린에서 추상 클래스는 클래스 선언에 abstract 키워드를 붙여 선언할 수 있다.
	- 메소드/프로퍼티에 abstract 키워드를 붙여 추상으로 만들 수 있다.
	
◎ object 객체와 클래스
	- object 키워드를 통해 익명 객체를 만들 수 있다. 만약 익명 객체의 프로퍼티나 함수가 접근이 지정되었다면 그 타입은 다음과 같다.
		- 만약 상속하지 않았다면 Any 타입이다.
		- 만약 타입 하나만 상속했다면 그 타입이 된다.
		- 만약 여러 타입을 상속했다면 명시한 타입이 된다.
	- object 키워드를 클래스 앞에 붙여서 싱글턴 클래스를 만들 수 있다. 이를 object 클래스라고 한다.
	- 당연히 상속할 수 있으며 클래스 이름으로 접근할 수 있다.
	- object 클래스의 초기화는 첫 접근 떄 스레드에 안전하게 초기화된다.
	
◎ 동반 객체
	- 동반 객체는 클래스 안에 object 클래스를 companion 키워드를 앞에 붙여 선언할 수 있다.
	- 동반 객체의 멤버는 동반 객체 부모의 이름으로 호출할 수 있다. 다른 언어의 static 기능이 동반 객체로 넘어간다고 생각하면 된다.
	- 동반 객체의 이름은 생략 가능하다. 이렇게 될 시 그 이름은 Companion이 되며, 그 부모의 이름으로도 참조 가능하다.