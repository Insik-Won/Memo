■ 6. 제네릭과 확장

◎ 제네릭
	- 자바처럼 클래스명 뒤/함수명 앞에 <T>를 붙여 제네릭 클래스/함수를 만들 수 있다.
	- 타입 추론이 가능하다면 제네릭 타입 사용 시 제네릭 인자를 명시하지 않을 수 있다.
	
◎ 공변성과 반공변성
	- 공변성은 상위 타입에 하위 타입을 할당할 수 있는 걸 뜻한다.
		- 공변성은 출력 위치에 쓰인다. 생산자가 사용하는 가변성이다.
	- 반공변성은 하위 타입에 상위 타입을 할당할 수 있는 걸 뜻한다.
		- 반공변성은 입력 위치에 쓰인다. 소비자가 사용하는 가변성이다.
		
	- 코틀린에서는 제네릭 타입 인자 앞에 in/out 키워드을 붙여서 반공변성/공변성을 표현할 수 있다. 키워드 이름이 직관적이다.
	
◎ 별표 표기법
	- 코틀린에서 제네릭 인자에 대한 정보가 없지만 안전하게 제네릭 클래스/함수를 쓰고 싶다면 별표(*)를 표기해서 사용한다.
		- Foo<out T : TUpper>인 경우 Foo<*>는 Foo<out TUpper>로 취급된다.
		- Foo<in T> 인 경우 Foo<*>는 Foo<in Nothing>으로 취급된다.
		- Foo<T : TUpper>인 경우 Foo<*>는 출력 위치에선 Foo<out TUpper>를, 입력 위치에선 Foo<in Nothing>으로 취급된다.
		
◎ 제네릭 타입 검사	
	- 제네릭 타입 검사는 컴파일 시간에만 이루어지며 제네릭 타입 객체는 런타임에 제네릭 타입과 관련된 아무런 정보를 가지지 않는다.
	
◎ 확장 함수
	- 확장 함수는 다음과 같이 정의한다.
		- fun 확장할타입이름.메소드이름(인자...) { ... }
	- 만약 이미 있는 멤버명을 사용하면 확장함수가 아닌 그 멤버가 호출된다.
	- 확장 함수 내에서는 해당 타입의 멤버를 아무 식별자 없이 접근할 수 있다.
	- 만약 클래스 내의 확장 함수에서 클래스 본인에 접근할려면 this@클래스명을 통해 접근할 수 있다. 
	- 확장 함수의 대상 타입에 제네릭 인자를 넣을 수도 있다. 신기하다.
	
	- 확장할 타입과 같은 파일에 정의된 탑레벨 확장 함수는 그 타입의 private 멤버에 접근할 수 있다.
	- 만약 확장할 타입 외부에 확장 함수가 정의되어있다면 그 함수는 private 멤버에 접근할 수 없다.
	
◎ 함수의 연산자화
	- 함수 앞에 infix를 붙여 그 함수를 이항 연산자로 바꿀 수 있다.
	
◎ 연산자 오버로딩
	- 클래스 내 연산자 오버로딩은 다음과 같이 정의한다.
		- operator fun 연산자이름(인자...) { ... }
	- 탑레벨 내 연산자 오버로딩은 다음과 같이 정의한다.
		- operator fun 확장타입.연산자이름(인자...) { ... }
	
	- 단항 연산자
		- +a -> a.unaryPlus()
		- -a -> a.unaryMinus()
		- !a -> a.not()	
	- 증감 연산자
		- a++ -> a.inc()
		- a-- -> a.dec()
		- 전위 연산은 연산자 호출 후 결과를 반환하고 후위 연산은 대상의 임시 객체를 만든 뒤 임시객체의 연산자 호출 결과를 대상에 적용하고 임시객체를 반환한다.
	- 이항 연산자
		- a + b -> a.plus(b)
		- a - b -> a.minus(b)
		- a * b -> a.times(b)
		- a / b -> a.div(b)
		- a % b -> a.rem(b)
		- a .. b -> a.rangeTo(b)
	- in 연산자
		- a in b - > b.contains(a)
		- a !in b -> !b.contains(a)
	- 인덱스 연산자
		- a[i] -> a.get(i)
		- a[i, j] -> a.get(i, j)
		- a[i_1, ... , i_n] -> a.get(i_1, ... , i_n)
		- a[i] = b -> a.set(i, b)
		- a[i, j] = b -> a.set(i, j, b)
		- a[i_1, ... , i_n] -> a.set(i_1, ... , i_n, b)
	- 호출 연산자
		- a() -> a.invoke()
		- a(i) -> a.invoke(i)
		- a(i, j) -> a.invoke(i, j)
		- a(i_1, .. , i_n) -> a.invoke(i_1, ... , i_n)
	- 할당 연산자
		- a += b -> a.plusAssign(b)
		- a -= b -> a.minusAssign(b)
		- a *= b -> a.timesAssign(b)
		- a /= b -> a.divAssign(b)
		- a %= b -> a.remAssign(b)
		- 할당 연산자의 반환 타입은 Unit이다. 코틀린에서 할당은 식이 아니다.
	- 동등 연산자
		- a==b -> a?.equals(b) ?: (b === null)
		- a!=b -> !(a?.equals(b) ?: (b === null)
		- ===와 !==는 오버로딩이 불가능하다.
	- 비교 연산자 
		- a > b -> a.compareTo(b) > 0
		- a < b -> a.compareTo(b) < 0
		- a >= b -> a.compareTo(b) >= 0
		- a <= b -> a.compareTo(b) <= 0
	- 프로퍼티 위임 연산자
		- provideDelegate, getValue, setValue 연산자는 프로퍼티 위임자에 사용된다.
		